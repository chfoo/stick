package stick;

import haxe.io.Path;
import haxe.io.Bytes;
import stick.Definition;

/*
    Generates the Haxe code for an extern class to maps one-to-one to the generated C file
*/
class ExternGenerator extends CodeGenerator {
    public function generate():Bytes {
        generateHeader();

        for (functionDef in definition.functions) {
            generateFunction(functionDef);
            writer.writeLine();
        }

        generateFooter();

        return output.getBytes();
    }

    function generateHeader() {
        writer.writeLine("// This file was generated by Stick");
        writer.writeLine('package ${config.haxePackage};');
        writer.writeLine();

        writer.writeLine("#if cpp");
        writer.writeLine('@:include("${Path.withoutDirectory(config.cNativeOutput)}")');
        writer.writeLine(config.cppInject);
        writer.writeLine("#end");
        writer.writeLine("@:keep");
        writer.writeLine('extern class ${config.haxeExternClass} {');
        writer.indent();
    }

    function generateFooter() {
        writer.unindent();
        writer.writeLine("}");
    }

    function generateFunction(functionDef:FunctionDef) {
        writer.writeLine("#if cpp");
        writer.writeLine('@:native("${config.cNativePrefix}${functionDef.name}")');
        writer.writeLine("#elseif hl");
        writer.writeLine('@:hlNative("${config.cLibraryName}", "${config.cNativePrefix}${functionDef.name}")');
        writer.writeLine("#end");

        writer.write('static function ${functionDef.name}(');

        writer.indent(2);
        writer.write(generateParameters(functionDef.parameters));
        writer.unindent(2);

        writer.write("):");
        switch functionDef.returnDef {
            case Some(def):
                writer.write(def.haxeType);
            case None:
                writer.write("Void");
        }
        writer.writeLine(";");
    }

    function generateParameters(parameters:Array<ParameterDef>):String {
        var output = [];

        for (paramDef in parameters) {
            output.push(generateParameter(paramDef));
        }

        return output.join(", ");
    }

    function generateParameter(paramDef:ParameterDef):String {
        return '${paramDef.name}:${paramDef.haxeType}';
    }
}
