package stick;

import haxe.io.Bytes;
import stick.Definition;

/*
    Generates the C wrapper code
*/
class NativeGenerator extends CodeGenerator {
    public function generate():Bytes {
        generateHeader();

        for (functionDef in definition.functions) {
            var functionGenerator = new FunctionGenerator(writer, config, functionDef);

            writer.writeLine('/* ${functionDef.name} */');
            functionGenerator.generateFunction();
            writer.writeLine();
            functionGenerator.generateHashLinkExportSignature();
            writer.writeLine();
            functionGenerator.generateHashLinkCAlias();
            writer.writeLine();
        }

        return output.getBytes();
    }

    function generateHeader() {
        writer.writeLine("// This file was generated by Stick");

        writer.writeLine("#include <stick.h>");
        writer.writeLine('#include <${config.cLibraryInclude}>');
        writer.writeLine();
    }
}


private class FunctionGenerator {
    var config:Config;
    var functionDef:FunctionDef;
    var writer:CodeWriter;

    public function new(writer:CodeWriter, config:Config, functionDef:FunctionDef) {
        this.writer = writer;
        this.config = config;
        this.functionDef = functionDef;
    }

    public function generateFunction() {
        writer.write("STICK_FUNC ");
        genReturnType();
        writer.write(' STICK_FUNC_NAME(${config.cNativePrefix}${functionDef.name}) ');
        writer.write("(");
        genSignatureParameters();
        writer.writeLine(") {");
        writer.indent();

        genParameterEmuLocalsForCall();
        genNativeCallReturnValueLocal();
        genNativeCall();
        genParameterEmuLocalsRestore();
        genNativeCallReturn();

        writer.unindent();
        writer.writeLine("}");
    }

    /*
        Generates the HashLink export signature

        Example: `DEFINE_PRIM(_I32, myFunc, _NO_ARGS)`
    */
    public function generateHashLinkExportSignature() {
        writer.writeLine("#ifdef LIBHL_EXPORTS");
        writer.write("DEFINE_PRIM(");
        genHashLinkExportReturn();
        writer.write(", ");
        writer.write(config.cNativePrefix);
        writer.write(functionDef.name);
        writer.write(", ");
        genHashLinkExportParameters();
        writer.writeLine(");");
        writer.writeLine("#endif");
    }

    /*
        Generates a function so that it appears as a symbol for HL/C.

        Example: `libraryName_libraryPrefixLibraryFunction` will call `hl_libraryPrefixLibraryFunction`.
    */
    public function generateHashLinkCAlias() {
        genReturnType();
        writer.write(" ");
        writer.write('${config.cLibraryName}_${config.cNativePrefix}${functionDef.name}');
        writer.write("(");
        genSignatureParameters();
        writer.writeLine(") {");
        writer.indent();

        genHashLinkCAliasCall();

        writer.unindent();
        writer.writeLine("}");
    }

    function getBindTypeString(bindType:BindType) {
        switch bindType {
            case Int32:
                return "int32_t";
            case Int32Pointer:
                return "int32_t*";
            case UInt32:
                return "uint32_t";
            case UInt32Pointer:
                return "uint32_t*";
            case Int64 | UInt64:
                return "STICK_INT64_EMU_T";
            case Int64Pointer | UInt64Pointer:
                return "STICK_INT64_EMU_T*";
            case ByteArray:
                return "STICK_BYTE_ARRAY_T";
            case CharArray:
                return "STICK_CHAR_ARRAY_T";
        }
    }

    /*
        Generates the wrapper function signature return type
        such as `void` or `int`.
    */
    function genReturnType() {
        switch functionDef.returnDef {
            case Some(def):
                writer.write(getBindTypeString(def.bindType));
            case None:
                writer.write("void");
        }
    }

    /*
        Generates the parameters in the wrapper function signature.
    */
    function genSignatureParameters() {
        for (index in 0...functionDef.parameters.length) {
            var parameter = functionDef.parameters[index];

            genSignatureParameter(parameter);

            if (index < functionDef.parameters.length - 1) {
                writer.write(", ");
            }
        }
    }

    function genSignatureParameter(parameterDef:ParameterDef) {
        writer.write(getBindTypeString(parameterDef.bindType));
        writer.write(" ");
        writer.write(parameterDef.name);
    }

    function genParameterEmuLocalsForCall() {
        for (parameter in functionDef.parameters) {
            genParameterEmuLocalForCall(parameter);
        }
    }

    function genParameterEmuLocalsRestore() {
        for (parameter in functionDef.parameters) {
            genParameterEmuLocalRestore(parameter);
        }
    }

    /*
        Generates local variable declarations for emulated types.

        For example, declare int64 for doubles emulating the Int64 type.
    */
    function genParameterEmuLocalForCall(parameter:ParameterDef) {
        switch parameter.bindType {
            case Int64:
                writer.write('STICK_INT64_T param_${parameter.name} = ');
                writer.write('STICK_INT64_EMU_TO_NATIVE(${parameter.name})');
                writer.writeLine(";");
            case UInt64:
                writer.write('STICK_UINT64_T param_${parameter.name} = ');
                writer.write('STICK_UINT64_EMU_TO_NATIVE(${parameter.name})');
                writer.writeLine(";");
            case Int64Pointer:
                writer.write('STICK_INT64_T param_${parameter.name} = ');
                writer.write('STICK_INT64_EMU_TO_NATIVE(*${parameter.name})');
                writer.writeLine(";");
            case UInt64Pointer:
                writer.write('STICK_UINT64_T param_${parameter.name} = ');
                writer.write('STICK_UINT64_EMU_TO_NATIVE(*${parameter.name})');
                writer.writeLine(";");
            default:
                // pass
        }
    }

    /*
        Generates conversions of native variable types to emulated types.

        For example, convert native int64 to a double (emulating Int64), and
        then set the double to the pointer coming from Haxe.
    */
    function genParameterEmuLocalRestore(parameter:ParameterDef) {
        switch parameter.bindType {
            case Int64Pointer:
                writer.write('*${parameter.name} = ');
                writer.write('STICK_INT64_NATIVE_TO_EMU(param_${parameter.name})');
                writer.writeLine(";");
            case UInt64Pointer:
                writer.write('*${parameter.name} = ');
                writer.write('STICK_UINT64_NATIVE_TO_EMU(param_${parameter.name})');
                writer.writeLine(";");
            default:
                // pass
        }
    }

    function genNativeCallReturnValueLocal() {
        switch functionDef.returnDef {
            case Some(def):
                writer.write('${def.nativeType} return_value = ');
            case None:
                // pass
        }
    }

    function genNativeCallReturn() {
        switch functionDef.returnDef {
            case Some(def):
                switch def.bindType {
                    case Int64:
                        writer.writeLine("return STICK_INT64_NATIVE_TO_EMU(return_value);");
                    case UInt64:
                        writer.writeLine("return STICK_UINT64_NATIVE_TO_EMU(return_value);");
                    case Int64Pointer | UInt64Pointer:
                        throw "Return with int64 pointer not supported";
                    default:
                        writer.writeLine("return return_value;");
                }
            case None:
                // pass
        }
    }

    function genNativeCall() {
        writer.write(functionDef.name);
        writer.write("(");

        for (index in 0...functionDef.parameters.length) {
            var parameter = functionDef.parameters[index];

            genNativeCallParameter(parameter);

            if (index < functionDef.parameters.length - 1) {
                writer.write(", ");
            }
        }

        writer.writeLine(");");
    }

    function genNativeCallParameter(parameter:ParameterDef) {
        // For emulation of Int64 using native `double` type
        switch parameter.bindType {
            case Int64 | UInt64:
                writer.write('param_${parameter.name}');
            case Int64Pointer | UInt64Pointer:
                writer.write('&param_${parameter.name}');
            default:
                writer.write(parameter.name);
        }
    }

    function genHashLinkExportReturn() {
        switch functionDef.returnDef {
            case Some(def):
                writer.write(getHashLinkSigType(def.bindType));
            case None:
                writer.write("_VOID");
        }
    }

    function genHashLinkExportParameters() {
        if (functionDef.parameters.length == 0) {
            writer.write("_NO_ARG");
        } else {
            for (parameter in functionDef.parameters) {
                writer.write(getHashLinkSigType(parameter.bindType));
                writer.write(" ");
            }
        }
    }

    function getHashLinkSigType(bindType:BindType):String {
        switch bindType {
            case Int32 | UInt32:
                return "_I32";
            case Int32Pointer | UInt32Pointer:
                return "_REF(_I32)";
            case Int64 | UInt64:
                return "_F64";  // Emulation of int64 using float64
            case Int64Pointer | UInt64Pointer:
                return "_REF(_F64)";  // Emulation of int64 using float64
            case ByteArray | CharArray:
                return "_BYTES";
        }
    }

    function genHashLinkCAliasCall() {
        if (functionDef.returnDef != None) {
            writer.write("return ");
        }

        writer.write('STICK_FUNC_NAME(${config.cNativePrefix}${functionDef.name})(');
        genHashLinkCAliasCallParameters();
        writer.write(')');
        writer.writeLine(";");
    }

    function genHashLinkCAliasCallParameters() {
        for (index in 0...functionDef.parameters.length) {
            var parameter = functionDef.parameters[index];

            writer.write(parameter.name);

            if (index < functionDef.parameters.length - 1) {
                writer.write(", ");
            }
        }
    }
}
